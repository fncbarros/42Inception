docker compose:
    - Stop all containers and remove volumes: docker compose down -v

docker:
    - List all containers and display only IDs: docker ps -q (or --quiet)
    - Stop all containers: docker stop $(docker ps -qa)
    - Remove all images: docker rmi $(docker images)
    - Remove all unused containers: docker rm $(docker ps -qa)
    - Remove all unused volumes: docker volume rm $(docker volume ls -q)
    - Remove all unused networks: docker network rm $(docker network ls -q) 2> /dev/null
    - Remove all unused data: docker system prune -a --volumes

docker-compose.yml:

services:
   service:
   build: /path/to/dockerfile
   image: specify docker image
   restart: specify what to do if container crashes
   networks:	what network should the	container be a part of
   volumes:
	- path/to/disk/folder:path/to/container/folder:<permission_specification(optional)> (permissions: ro(read-o\
nly); rw(read-write))


ports:
 - "443:443"
    or
 - "127.0.0.1:443:443"

Specify both ports (HOST:CONTAINER),
specify just the container port (an ephemeral host port is chosen for the host port).
or specify the host IP address to bind to AND both ports (the default is 0.0.0.0, meaning all interfaces): (IPADDR:HOSTPORT:CONTAINERPORT). If HOSTPORT is empty (for example 127.0.0.1::80), an ephemeral port is chosen to bind to on the host.

Long form
ports:

  - target: 443     the port inside the container
    published: 443  the publicly exposed port
    protocol: tcp   the port protocol (tcp or udp)
    mode: host      host for publishing a host port on each node, or ingress for a swarm mode port to be load balanced.


Multi-stage build example:
# syntax=docker/dockerfile:1
FROM golang:1.16-alpine AS build

# Install tools required for project
# Run `docker build --no-cache .` to update dependencies
RUN apk add --no-cache git
RUN go get github.com/golang/dep/cmd/dep

# List project dependencies with Gopkg.toml and Gopkg.lock
# These layers are only re-built when Gopkg files are updated
COPY Gopkg.lock Gopkg.toml /go/src/project/
WORKDIR /go/src/project/
# Install library dependencies
RUN dep ensure -vendor-only

# Copy the entire project and build it
# This layer is rebuilt when a file changes in the project directory
COPY . /go/src/project/
RUN go build -o /bin/project

# This results in a single layer image
FROM scratch
COPY --from=build /bin/project /bin/project
ENTRYPOINT ["/bin/project"]
CMD ["--help"]

Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD.
COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious.
Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.

If you have multiple Dockerfile steps that use different files from your context, COPY them individually, rather than all at once.
This ensures that each step’s build cache is only invalidated, forcing the step to be re-run if the specifically required files change.

